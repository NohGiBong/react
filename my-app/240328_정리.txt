










        @useEffect (이펙트 함수, 의존성 배열);
        @ 의존성 배열 안에 있는 변수 중에 하나라도 값이 변경되었을 때 이펙트 함수가 실행됨.
        @ 의존성 배열에 빈 배열([])을 넣으면 마운트와 언마운트 시에 단 한 번씩만 실행됨
        @ 의존성 배열 생략 시 컴포넌트가 업데이트될 때마다 호출됨
        @ 선언된 컴포넌트의 props와 state에 접근할 수 있음
        @useEffect()에서 리턴하는 함수는 컴포넌트 마운트가 해제될 때 호출됨
 useMemo ()













    *사용법
        @ 그렇지 않은 경우에는 기존 함수의 결과값을 그대로 반환함
        @ 의존성 배열을 넣지 않을 경우 렌더링이 일어날 때마다 매번 값 생성 함수가 실행되므로 의미가 없음
- useCallback()
    * useMemo() 훅과 유사하지만 값이 아닌 함수를 반환한다는 점이 다름
    * useCallback(콜백 함수, 의존성 배열); 은 useMemo(() => 콜백 함수, 의존성 배열);과 동일
컴포넌트 내에 함수를 정의하면 매번 렌더링이 일어날 때마다 함수가 새로 정의되므로
- useCallback() 훅을 사용하여 불필요한 함수 재정의 작업을 없애는 것
    *사용법
        @ const memoizedCallback = useCallback(콜백함수, 의존성 배열);
        @ 의존성 배열에 들어 있는 변수가 변했을 경우에만 콜백 함수를 다시 정의해서 리턴함.
- useRef()
    * 레퍼런스를 사용하기 위한 훅
    * 레퍼런스란 특정 컴포넌트에 접근할 수 있는 객체를 의미
    * 매번 렌더링될 때마다 항상 같은 레퍼런스 객체를 반환
    * 사용법
        @ const refContainer = useRef(초기값);
        @ .current라는 속성을 통해서 접근

훅의 규칙
    - 무조건 최상위 레벨에서만 호출해야 함
        *반복문이나 조건문 또는 중첩된 함수들 안에서 훅을 호출하면 안됨.
        * 컴포넌트가 렌더링될 때마다 매번 같은 순서로 호출되어야 함
    - 리액트 함수 컴포넌트에서만 훅을 호출해야 함
        *훅은 리액트 함수 컴포넌트에서 
        호출하거나 직접 만든 커스텀 훅에서만 호출할 수 있음
커스텀 훅
    - 이름이 use로 시작하고 내부에서 다른 훅을 호출하는 단순한 자바스크립트 함수
    - 파라미터로 무엇을 받을지, 어떤 것을 리턴할지를 개발자가 직접 정할 수 있음.
    - 중복되는 로직을 커스텀 훅으로 추출하여 재사용성을 높일 수 있음
    - 이름이 use로 시작하지 않으면 특정 함수의 내부에서 훅을 호출하는지 알 수 없기 때문에
        훅의 규칙 위반 여부를 자동으로 확인할 수 없음.
